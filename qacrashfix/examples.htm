<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN">
<html><head><meta http-equiv="Content-Type" content="text/html; charset=GBK">
    <link rel="stylesheet" type="text/css" href="./index_files/style.css">
    <title>QACrashFix</title>
<body bgcolor="#eeeeee" border="1"cellpadding="5"cellspacing="0"width="100%">
<div id="container">
	<div id="header">
		<h1>QACrashFix</h1>
	</div> <!-- end header -->

<div id="sidebar">
 <div id="sidebar2"> 
  <ul>
   <li> <a href="./home.htm">About</a>
   </li><li> <a href="./home.htm#Download">Download</a>
   </li><li> <a href="./tutorial.htm">Tutorial</a> 
   </li><li> <a href="./home.htm#Publication">Publication</a>
   </li><li> <a href="./home.htm#Contributors">Contributors</a>
  </li>
  <li> <a href="./home.htm#References">References</a>
  </li><li> <a href="./examples.htm">Examples</a>
  </li></ul>
 </div>
</div>


<div id="main">
<p>In this page we analyze the first filtered patches generated by QACrashFix in the experiment described in <a href="./home.htm#Publication">our paper</a>. In total we generated at least one patches for 10 bugs. In each graph below, the top one represents the original patch generated by the developers, and the bottom one represents the patch generated by our tool.</p>

<p>i) For 3 of the 10 bugs (Fig. 1, 2, 3), our tool generated the same patch as humans.</p>

<dl><li>Fig. 1 shows a common bug extracted
by our tool: developers may forget to destroy the objects of the superclass before they destroy the current object.</li>
<img width="450"  src="examples/1.png"/>
<li>Fig. 2 shows a
wrong parameter of the original code. By calling getApplicationContext(), we get the context of the whole application instead
of one activity, and the context is alive during the lifetime of the whole application.</li>
<img width="450"  src="examples/2.png"/>
<li>Fig. 3 shows another common mistake
made by humans. When a status is commited via calling commit(), the application will fail if it loses the status. However, if we
allow the loss of the state, we can fix the crash by calling commitAllowingStateLoss().</li>
<img width="450"  src="examples/3.png"/></dl>

<p>ii) For 4 of 10 bugs (Fig. 4, 5, 6, 7), though our tool did not generate identical patches, it still generated correct and
sometimes even better patches.</p>

<dl><li>In Fig. 4, the generated patch has one more condition that check dialog is not null. This is a useful
check that ensures no NullPointerException before using dialog.</li> 
<img width="450"  src="examples/4.png"/>

<li>Fig. 5 shows a similar bug like Fig. 3. By calling dismiss,
we close the dialog and save its status. If we lose the status the application will crash. Calling dismissAllowingStateLoss solves
the problem. In the human fix, there are two locations that have the same fix. Because in QACrashFix we can only identify Line
72 as the fault location, we only generate one patch. However, by running the program again, in the case of MESSAGE_EXCEPTION
there will be another crash with Line 77 as the fault location, and then we can generate the other fix identical to human. This suggests that QACrashFix can be used iteratively to fix crash bugs.</li>
<img width="450"  src="examples/5.png"/>

<li>Fig. 6 shows a misspelled file format ¡°jpg¡±, which should
be changed to ¡°jpeg¡±. According to the answer, we change it to a more general type ¡°*¡±, which contains the ¡°jpeg¡± occasion. In addition the a ¡°try/catch¡± block is added.</li>
<img width="450"  src="examples/6.png"/>

<li>Fig. 7 shows a similar bug where the superclass object is not destroyed. Although humans write more fixes, they are not related
to the crash bug ¡°SuperNotCalledException¡±, and our generated patch is correct.</li>
<img width="450"  src="examples/7.png"/></dl>

<p>iii) For 1 of 10 bugs, our tool generated a patch using try and catch blocks as suggested in the Stack Overflow page,
shown in Fig. 8.</p>

<dl><li>The human patch invokes isFinishing() and returns when finished. In our patch, we surround finish() with
try/catch, which deals with the same root cause. However, because the patch is different from the human patch, we consider
it as a correct but not acceptable patch.</li>
<img width="450"  src="examples/8.png"/></dl>

<p>iv) For the rest 2 of the 10 bugs (Fig. 9, 10), our tool generated two erroneous patches.</p> 
<dl><li>In
Fig 9, we generated a patch that deals with the same root cause as suggested by an Stack Overflow answer: the View object is
not added into an Android Activity object. However, the patch is very different from the human patch, and we cannot verify its
correctness.</li>
<img width="450"  src="examples/9.png"/>

<li>In Fig 10, the generated patch only inserts a null check, and is different from the human patch. Therefore, it is also
not a correct patch.</li>
<img width="450"  src="examples/10.png"/></dl>

</div>
<div id="wapper">  
    HTML style inspired from <a href="http://www.cs.cornell.edu/projects/crystal/fastcheck/">Fastcheck</a>
    <div id="main-content">  
    </div>  
    <!-- Ò³½Å -->  
    <div id="footer">  
    </div>  
</div>

</body></html>
