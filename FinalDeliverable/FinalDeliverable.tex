% This is "sig-alternate.tex" V2.1 April 2013
% This file should be compiled with V2.5 of "sig-alternate.cls" May 2012
%
% This example file demonstrates the use of the 'sig-alternate.cls'
% V2.5 LaTeX2e document class file. It is for those submitting
% articles to ACM Conference Proceedings WHO DO NOT WISH TO
% STRICTLY ADHERE TO THE SIGS (PUBS-BOARD-ENDORSED) STYLE.
% The 'sig-alternate.cls' file will produce a similar-looking,
% albeit, 'tighter' paper resulting in, invariably, fewer pages.
%
% ----------------------------------------------------------------------------------------------------------------
% This .tex file (and associated .cls V2.5) produces:
%       1) The Permission Statement
%       2) The Conference (location) Info information
%       3) The Copyright Line with ACM data
%       4) NO page numbers
%
% as against the acm_proc_article-sp.cls file which
% DOES NOT produce 1) thru' 3) above.
%
% Using 'sig-alternate.cls' you have control, however, from within
% the source .tex file, over both the CopyrightYear
% (defaulted to 200X) and the ACM Copyright Data
% (defaulted to X-XXXXX-XX-X/XX/XX).
% e.g.
% \CopyrightYear{2007} will cause 2007 to appear in the copyright line.
% \crdata{0-12345-67-8/90/12} will cause 0-12345-67-8/90/12 to appear in the copyright line.
%
% ---------------------------------------------------------------------------------------------------------------
% This .tex source is an example which *does* use
% the .bib file (from which the .bbl file % is produced).
% REMEMBER HOWEVER: After having produced the .bbl file,
% and prior to final submission, you *NEED* to 'insert'
% your .bbl file into your source .tex file so as to provide
% ONE 'self-contained' source file.
%
% ================= IF YOU HAVE QUESTIONS =======================
% Questions regarding the SIGS styles, SIGS policies and
% procedures, Conferences etc. should be sent to
% Adrienne Griscti (griscti@acm.org)
%
% Technical questions _only_ to
% Gerald Murray (murray@hq.acm.org)
% ===============================================================
%
% For tracking purposes - this is V2.0 - May 2012

\documentclass{sig-alternate-05-2015}
\usepackage{graphicx}
\usepackage[usenames,dvipsnames]{color}
\usepackage{soul} 
\usepackage{booktabs}

\newcommand{\todo}[1]
  {{\scriptsize \textbf{\color{red} {#1}}}}


\graphicspath{ {} }


\begin{document}

% Copyright
% \setcopyright{acmcopyright}
%\setcopyright{acmlicensed}
%\setcopyright{rightsretained}
%\setcopyright{usgov}
%\setcopyright{usgovmixed}
%\setcopyright{cagov}
%\setcopyright{cagovmixed}


\CopyrightYear{2016}
\setcopyright{acmcopyright}
\conferenceinfo{MSR'16,}{May 14-15, 2016, Austin, TX, USA}
\isbn{978-1-4503-4186-8/16/05}
\acmPrice{\$15.00}
\doi{http://dx.doi.org/10.1145/2901739.2903495}



% DOI
% \doi{10.475/123_4}

% ISBN
% \isbn{978-1-4503-4186-8}

%Conference
%\conferenceinfo{PLDI '13}{June 16--19, 2013, Seattle, WA, USA}

%\acmPrice{\$0.00}

%
% --- Author Metadata here ---
\conferenceinfo{MSR}{2016 Austin, Texas USA}
%\CopyrightYear{2007} % Allows default copyright year (20XX) to be over-ridden - IF NEED BE.
%\crdata{0-12345-67-8/90/01}  % Allows default copyright data (0-89791-88-6/97/05) to be over-ridden - IF NEED BE.
% --- End of Author Metadata ---

\title{Building a probabilistic model of statement replacements for automatic bug fixing based on an empirical study of real Java bug fixes}

%
% You need the command \numberofauthors to handle the 'placement
% and alignment' of the authors beneath the title.
%
% For aesthetic reasons, we recommend 'three authors at a time'
% i.e. three 'name/affiliation blocks' be placed beneath the title.
%
% NOTE: You are NOT restricted in how many 'rows' of
% "name/affiliations" may appear. We just ask that you restrict
% the number of 'columns' to three.
%
% Because of the available 'opening page real-estate'
% we ask you to refrain from putting more than six authors
% (two rows with three columns) beneath the article title.
% More than six makes the first-page appear very cluttered indeed.
%
% Use the \alignauthor commands to handle the names
% and affiliations for an 'aesthetic maximum' of six authors.
% Add names, affiliations, addresses for
% the seventh etc. author(s) as the argument for the
% \additionalauthors command.
% These 'additional authors' will be output/set for you
% without further effort on your part as the last section in
% the body of your article BEFORE References or any Appendices.

\numberofauthors{1} %  in this sample file, there are a *total*
% of EIGHT authors. SIX appear on the 'first-page' (for formatting
% reasons) and the remaining two appear in the \additionalauthors section.
%
\author{
% You can go ahead and credit any number of authors here,
% e.g. one 'row of three' or two rows (consisting of one row of three
% and a second row of one, two or three).
%
% The command \alignauthor (no curly braces needed) should
% precede each author name, affiliation/snail-mail address and
% e-mail address. Additionally, tag each line of
% affiliation/address with \affaddr, and tag the
% e-mail address with \email.
%
% 1st. author
\alignauthor
Mauricio Soto, Selva Samuel\\
       \affaddr{School of Computer Science, Carnegie Mellon University, Pittsburgh, PA}\\
       \email{mauriciosoto@cmu.edu, ssamuel@andrew.cmu.edu} 
}
% There's nothing stopping you putting the seventh, eighth, etc.
% author on the opening page (as the 'third row') but we ask,
% for aesthetic reasons that you place these 'additional authors'
% in the \additional authors block, viz.
%\additionalauthors{Additional authors: John Smith (The Th{\o}rv{\"a}ld Group,
%email: {\texttt{jsmith@affiliation.org}}) and Julius P.~Kumquat
%(The Kumquat Consortium, email: {\texttt{jpkumquat@consortium.net}}).}
\date{February 2, 2016}
% Just remember to make sure that the TOTAL number of authors
% is the number that will appear on the first page PLUS the
% number that will appear in the \additionalauthors section.

\maketitle
\begin{abstract}

With the rise of automated program repair in the last couple of years, there are a lot of questions to remain unanswered. We performed a study on 100 open source projects, in which we analyzed the 20 most recent bug fixing commits of this dataset, and found all the replacements made in these 62,470 commits from real life projects in Github.

We found very valuable information to guide automatic software repair, such as the most common and least common replacements made by human developers in order to build a successful patch; we analyzed the most and least common statement to replace others, and the most and least likely statement to get replaced by other. We also analyzed, once you have a statement that you want to replace (a faulty statement), what are the most likely statements to replace it for. These information will help automatic program repair tools to be more maintainable and user friendly, taking it one step closer to what humans developers do to repair their code.
We performed an evaluation for our model, that shows via 10-fold cross validation that our model can predict replacements in a 78.52\% of the times in the first 3 guesses. Finally we also performed a study to validate the accuracy of the regular expression being normally use to find bug fixing commits.

\end{abstract}


%
% The code below should be generated by the tool at
% http://dl.acm.org/ccs.cfm
% Please copy and paste the code instead of the example below. 
%
\begin{CCSXML}
<ccs2012>
 <concept>
  <concept_id>10010520.10010553.10010562</concept_id>
  <concept_desc>Computer systems organization~Embedded systems</concept_desc>
  <concept_significance>500</concept_significance>
 </concept>
 <concept>
  <concept_id>10010520.10010575.10010755</concept_id>
  <concept_desc>Computer systems organization~Redundancy</concept_desc>
  <concept_significance>300</concept_significance>
 </concept>
 <concept>
  <concept_id>10010520.10010553.10010554</concept_id>
  <concept_desc>Computer systems organization~Robotics</concept_desc>
  <concept_significance>100</concept_significance>
 </concept>
 <concept>
  <concept_id>10003033.10003083.10003095</concept_id>
  <concept_desc>Networks~Network reliability</concept_desc>
  <concept_significance>100</concept_significance>
 </concept>
</ccs2012>  
\end{CCSXML}


%
% End generated code
%

%
%  Use this command to print the description
%
\printccsdesc

% We no longer use \terms command
%\terms{Theory}

\keywords{Automatic error repair; Maintainability; Replacements}

\section{Introduction}



Automatic bug repair is the branch of computer science that deals with automated ways to repair errors in software(e.g.,~\cite{kim2013,legoues2012,
  Mechtaev15,Long2016}). There have been several approaches taken towards improving the different methodologies to repair bugs in software automatically \cite{dongsun}\cite{weimer}\cite{claire} \cite{kai}, one of the most accepted approaches so far has been GenProg \cite{weimer}\cite{claire}, a tool which combines stochastic search methods like genetic programming with lightweight program analyses to find patches for real bugs in existing software. This evolutionary program repair tool applies four different kinds of possible changes to code in order to find a patch for a given bug. These changes are the following: Delete, Replace, Swap and Append.

Our research aims to provide guidelines to improve one of these possible changes. The one which remains to be unstudied since it is probably the hardest of them: Replace. It will provide the data necessary for this tool and other approaches to have a guide on what is the way in which human programmers change their code when coding a fix for a bug. This way it will make it more likely for automatic error repair approaches to succeed in finding a patch for a particular error, and also, to provide automatic error repair software with heuristics to make the patches more human-like and therefore more readable and maintainable by human developers.

In this article we perform an empirical study that consists of mining 100 open source projects, and determining the frequency with which human programmers replace different statements to their source code in order to fix a bug.



In this paper, we study bug-fixing commits to Java programs, 
taken from several thousand human-made bug fixes from Github. We make
observations to directly guide future research in automatic repair of Java
programs, to increase the success rate of such techniques and the degree to
which the patches are human-like and therefore more readable and maintainable by
human developers. This is important, because patch quality is an important
concern in this area~\cite{Qi15}.

% On the other hand, some approaches~\cite{kim2013} search for specific patterns
% and modify source code according to predefined templates. A well known approach
% is PAR~\cite{kim2013}, which creates 10 different repair templates and applies
% them to the buggy code in an effort to repair it. In this paper we have taken 8
% out of the 10 PAR templates and tested how common they are in the repairs made
% by programmers in the latest official data dump of Github as of September 2015
% provided by~\cite{dyer2013}.  Our results provide evidence of how common those
% patterns are in practice. We take as reference the study performed by Dongsun
% Kim et al.~\cite{kim2013} in which they look for the most common ways in which
% programmers patch bugs in software. The researchers developed a variation of the
% tool Genprog~\cite{weimer2009,legoues2012} with several different templates
% resembling patterns programmers use to patch bugs, and then performed an
% empirical study to evaluate which patches do human programmers prefer.

\vspace{1ex} \noindent\textbf{Related work.} Zhong and Su~\cite{zhong2015} ask
some of the same questions we do, on 6 projects. We study a mutation operation that these researchers left out due to its complexity, which is the operator Replace, and we also look at more statement types than the previous work.. Similar to our study in
Section~\ref{sec:stmtstudy}, researchers have 
studied AST-level~\cite{Martinez:2015ez} and line-level
changes~\cite{Asaduzzaman:2013df} across bug fixing commits.
Although it is worth notice that so far none of these approaches have studied in depth the Replace operator.
An important study was done in this subject by Soto et al [CITATION] in which they count the number of statements in the before-fix and after-fix versions of the code and try to infer a correlation between the two number of statements. This study avoids this assumption, and instead creates a direct comparison between the two abstract syntax trees to be able to infer more accurately when replacements are being made and create the model with this data.

\section{Dataset and Characteristics}
For the dataset of this project we picked the 100 Java projects in Github with the most stars. In Github when a user stars a project it means that the user is:
\begin{itemize}
  \item Creating a bookmark for easier access
  \item Showing appreciation to the repository maintainer for their work
\end{itemize}

Therefore, by picking the projects with more stars we are taking the Java projects more liked and supported by the community and developers of Github, which may have a correlation with having a lot of followers, contributors and activity; and this diversity benefits our study since having a larger diversity of bug fixes, makes the model being built from this data more reliable and more diverse.

From each of these 100 projects we picked the last 20 bug fixing commits for two reasons. First, we had time restrictions, and making it with more than 20 commits became very time consuming. As a sample of this, for the first project, we tried getting all the bug fixing commits and cloning the before-fix and after-fix versions of each of the commits. We had to stop this process when the commits were taking 65 gigs of space just for the first project. Therefore we considered that taking the last 20 commits would be a good balance between depth of each project and would also allow us to get the breadth we were looking by in analyzing 100 different projects. 

The problem of categorizing which commits are actually bug fixing commits or not is an open problem in the literature. This is usually performed by applying a regular expression to the commit message, and this way inferring if a commit is a bug fixing commit or not depending on the words the commit message has. We used as inspiration the regular expression used by Boa [CITATION] to find bug fixing commits. We used a very similar regular expression to determine this, which is the following:
\begin{itemize}
  \item "[Ff]ix(ed|es|ing)?(\textbackslash s)*([Bb]ug|[Ii]ssue|[Pp]roblem)?(s)?"
\end{itemize}

To address the concern of knowing if this regular expression would get the commits that are actually bug fixing commits or not, we made the study in the following section.

\subsection{Commit validation}


\section{Replacements and QACrashFix}


\section{Building the model}

In order to build the probabilistic model we gather the data from the 100 projects. From each of these projects we took the 20 latest bug fixing commits, and each of these bug fixing commits consists of a variable number of files, which can vary between 1 to even a couple of hundreds.
We ran the scripts to gather the data to build the model for 4 days straight on a laptop with an Intel i7 processor and 8 gigs of RAM. We added all the instances of replacements that we found in our dataset and with these, we modeled the distribution of replacements performed by human programmers when patching bugs.

According to The Eclipse Java development tools (JDT) \footnote{http://www.eclipse.org/jdt/}, the java language contains 22 different kinds of statements. We based our model and results on these 22 statement types. Since the names of the statement types are very long, we created abbreviations for all of them so that the table of the model is clearer. The abbreviations for the statement types are the following:

\begin{verbatim}
As: AssertStatement
Bl: Block
Br: BreakStatement
CI: ConstructorInvocation
Co: ContinueStatement
Do: DoStatement
Em: EmptyStatement
EF: EnhancedForStatement
Ex: ExpressionStatement
Fo: ForStatement
If: IfStatement
La: LabeledStatement
Re: ReturnStatement
SC: SuperConstructorInvocation
Ca: SwitchCase
Sw: SwitchStatement
Sy: SynchronizedStatement
Th: ThrowStatement
Tr: TryStatement
TD: TypeDeclarationStatement
VD: VariableDeclarationStatement
Wh: WhileStatement
\end{verbatim}



\begin{table*}
	\centering
	\resizebox{\textwidth}{!}{
	%\renewcommand{\arraystretch}{0.9}% Tighter
		\begin{tabular}{l|rrrrrrrrrrrrrrrrrrrrrr} \toprule
 				&\texttt{As}&\texttt{Bl}&\texttt{Br}&\texttt{CI}&\texttt{Co}&\texttt{Do}&\texttt{Em}&\texttt{EF}&\texttt{Ex}&\texttt{Fo}&\texttt{If}&\texttt{La}&\texttt{Re}&\texttt{SC}&\texttt{Ca}&\texttt{Sw}&\texttt{Sy}&\texttt{Th}&\texttt{Tr}&\texttt{TD}&\texttt{VD}&\texttt{Wh}
		

			\\ \midrule
\texttt{As}	&0&	0&	0&	0&	0&	0&	0&	0&	25&	0&	25&	0&	25&	0&	0&	0&	0&	0&	0&	0&	25&	0\\
\texttt{Bl}	&0&	0&	0&	1&	0&	0&	0&	0&	33&	0&	15&	0&	31&	0&	0&	0&	0&	0&	0&	0&	19&	0\\
\texttt{Br}	&0&	0&	0&	0&	0&	0&	0&	0&	48&	0&	12&	0&	0&	0&	40&	0&	0&	0&	0&	0&	0&	0\\
\texttt{CI}	&0&	10&	0&	0&	0&	0&	0&	0&	0&	0&	0&	0&	10&	80&	0&	0&	0&	0&	0&	0&	0&	0\\
\texttt{Co}	&0&	0&	0&	0&	0&	0&	0&	0&	0&	0&	0&	0&	100&	0&	0&	0&	0&	0&	0&	0&	0&	0\\
\texttt{Do}	&0&	0&	0&	0&	0&	0&	0&	0&	100&	0&	0&	0&	0&	0&	0&	0&	0&	0&	0&	0&	0&	0\\
\texttt{Em}	&0&	0&	0&	0&	0&	0&	0&	0&	0&	0&	0&	0&	0&	0&	0&	0&	0&	0&	0&	0&	0&	0\\
\texttt{EF}	&0&	12&	0&	0&	0&	0&	0&	0&	54&	4&	12&	0&	0&	0&	0&	0&	0&	0&	12&	0&	8&	0\\
\texttt{Ex}	&0&	26&	3&	0&	0&	0&	0&	1&	0&	0&	13&	0&	3&	0&	0&	0&	0&	1&	3&	0&	50&	0\\
\texttt{Fo}	&0&	8&	0&	0&	0&	0&	0&	17&	0&	0&	0&	0&	75&	0&	0&	0&	0&	0&	0&	0&	0&	0\\
\texttt{If}	&0&	19&	2&	0&	0&	0&	0&	1&	52&	0&	0&	0&	9&	0&	0&	0&	0&	0&	3&	0&	14&	0\\
\texttt{La}	&0&	0&	0&	0&	0&	0&	0&	0&	0&	0&	0&	0&	0&	0&	0&	0&	0&	0&	0&	0&	0&	0\\
\texttt{Re}	&0&	2&	0&	2&	5&	0&	0&	0&	43&	0&	22&	0&	0&	2&	2&	0&	0&	3&	2&	0&	19&	0\\
\texttt{SC}	&0&	8&	0&	54&	0&	0&	0&	0&	23&	0&	0&	0&	0&	0&	0&	0&	0&	0&	0&	0&	15&	0\\
\texttt{Ca}	&0&	0&	30&	0&	0&	0&	0&	0&	20&	0&	10&	0&	30&	0&	0&	0&	0&	0&	0&	0&	10&	0\\
\texttt{Sw}	&0&	33&	0&	0&	0&	0&	0&	0&	0&	0&	67&	0&	0&	0&	0&	0&	0&	0&	0&	0&	0&	0\\
\texttt{Sy}	&0&	0&	0&	0&	0&	0&	0&	0&	10&	0&	20&	0&	0&	0&	0&	0&	0&	0&	70&	0&	0&	0\\
\texttt{Th}	&0&	0&	0&	0&	0&	0&	0&	0&	71&	0&	0&	0&	29&	0&	0&	0&	0&	0&	0&	0&	0&	0\\
\texttt{Tr}	&0&	0&	0&	0&	0&	0&	0&	0&	26&	0&	9&	0&	4&	0&	0&	0&	30&	0&	0&	0&	30&	0\\
\texttt{TD}	&0&	0&	0&	0&	0&	0&	0&	0&	0&	0&	0&	0&	0&	0&	0&	0&	0&	0&	0&	0&	0&	0\\
\texttt{VD}	&0&	6&	0&	0&	0&	0&	0&	1&	81&	1&	6&	0&	2&	0&	0&	0&	0&	0&	2&	0&	0&	0\\
\texttt{Wh}	&0&	0&	0&	0&	0&	0&	0&	0&	0&	0&	0&	0&	0&	0&	0&	0&	0&	0&	0&	0&	0&	0\\
			\\ \bottomrule
		\end{tabular}
		}
		\caption{Likelihood of replacing a statement type (row) by a statement of
          another type (column), for Java.}\label{tab:likeliness}
\end{table*}


\section{Evaluation}\label{sec:stmtstudy}
For the evaluation section we wanted to know how likely is it that our model can predict the behavior of real bug fixes performed by humans.
Therefore we decided to evaluate our model using 10-fold cross validation.



\section{Discussion and Future work}
Our work is publicly available to be downloaded, extended and reproduced by anyone.\footnote{https://github.com/mausotog/ReplacementsEmpiricalStudy}


\section{Acknowledgments}


\bibliographystyle{abbrv}
\bibliography{sigproc}  % sigproc.bib is the name of the Bibliography in this case
% You must have a proper ".bib" file
%  and remember to run:
% latex bibtex latex latex
% to resolve all references
%
% ACM needs 'a single self-contained file'!
%
%APPENDICES are optional
%\balancecolumns


%\balancecolumns % GM June 2007
% That's all folks!
\end{document}
