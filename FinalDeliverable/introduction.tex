% !TEX root = FinalDeliverable.tex

\section{Introduction}

Automatic bug repair is the branch of software engineering that deals with automated ways to repair errors in software without requiring human intervention~\cite{kim2013, legoues2012, Mechtaev15, Long2016}. There have been several approaches taken towards improving the different methodologies to repair bugs in software automatically~\cite{kim2013, weimer2009, legoues2012, kai}. One of the more successful approaches so far has been GenProg~\cite{weimer2009, legoues2012}, a tool which combines stochastic search methods like genetic programming with lightweight program analyses to find patches for real bugs in software. Based on evolutionary computation, GenProg applies four different kinds of possible changes to code in order to find a patch for a given bug. These changes are: (1) delete, (2) replace, (4) swap, and (4) append.

Our research aims to provide guidelines to improve one of these possible changes. The one which remains to be unstudied since it is probably the hardest of them: Replace. It will provide the data necessary for this tool and other approaches to have a guide on what is the way in which human programmers change their code when coding a fix for a bug. This way it will make it more likely for automatic error repair approaches to succeed in finding a patch for a particular error, and also, to provide automatic error repair software with heuristics to make the patches more human-like and therefore more readable and maintainable by human developers.

In this article we perform an empirical study that consists of mining 100 open source projects, and determining the frequency with which human programmers replace different statements to their source code in order to fix a bug.

In this paper, we study bug-fixing commits to Java programs, 
taken from several thousand human-made bug fixes from Github. We make
observations to directly guide future research in automatic repair of Java
programs, to increase the success rate of such techniques and the degree to
which the patches are human-like and therefore more readable and maintainable by
human developers. This is important, because patch quality is an important
concern in this area~\cite{Qi15}.

% On the other hand, some approaches~\cite{kim2013} search for specific patterns
% and modify source code according to predefined templates. A well known approach
% is PAR~\cite{kim2013}, which creates 10 different repair templates and applies
% them to the buggy code in an effort to repair it. In this paper we have taken 8
% out of the 10 PAR templates and tested how common they are in the repairs made
% by programmers in the latest official data dump of Github as of September 2015
% provided by~\cite{dyer2013}.  Our results provide evidence of how common those
% patterns are in practice. We take as reference the study performed by Dongsun
% Kim et al.~\cite{kim2013} in which they look for the most common ways in which
% programmers patch bugs in software. The researchers developed a variation of the
% tool Genprog~\cite{weimer2009,legoues2012} with several different templates
% resembling patterns programmers use to patch bugs, and then performed an
% empirical study to evaluate which patches do human programmers prefer.

\vspace{1ex} \noindent\textbf{Related work.} Zhong and Su~\cite{zhong2015} ask
some of the same questions we do, on 6 projects. We study a mutation operation that these researchers left out due to its complexity, which is the operator Replace, and we also look at more statement types than the previous work.. Similar to our study in
Section~\ref{sec:stmtstudy}, researchers have 
studied AST-level~\cite{Martinez:2015ez} and line-level
changes~\cite{Asaduzzaman:2013df} across bug fixing commits.
Although it is worth notice that so far none of these approaches have studied in depth the Replace operator.
An important study was done in this subject by Soto et al~\cite{soto} in which they count the number of statements in the before-fix and after-fix versions of the code and try to infer a correlation between the two number of statements. This study avoids this assumption, and instead creates a direct comparison between the two abstract syntax trees to be able to infer more accurately when replacements are being made and create the model with this data.
